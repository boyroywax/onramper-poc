"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateDate = void 0;
const constants_1 = require("../constants");
const dynamodb_1 = __importDefault(require("../utils/dynamodb"));
const token_1 = require("../utils/token");
const dynamoTxs_1 = require("./dynamoTxs");
const isoAlpha2ToAlpha3_1 = __importDefault(require("../utils/isoAlpha2ToAlpha3"));
const moonpayCountryData_1 = require("../moonpayCountryData");
const getNextKYCStep_1 = __importDefault(require("./getNextKYCStep"));
const fetch_1 = __importDefault(require("../utils/fetch"));
const items_1 = require("./items");
const errors_1 = require("../errors");
function generateDate({ year, month, day }) {
    const pad = (strN, n) => String(strN).padStart(n, "0");
    return `${pad(year, 4)}-${pad(month, 2)}-${pad(day, 2)}T00:00:00.000Z`;
}
exports.generateDate = generateDate;
// The country used in this call is a country directly provided by the user,
// not the one we guess based on their IP address
function default_1(id, onramperApiKey, firstName, lastName, dateOfBirth, street, town, postCode, state, providedCountry) {
    return __awaiter(this, void 0, void 0, function* () {
        const tokenTx = dynamoTxs_1.getTxAuthToken(id);
        const creationTx = dynamoTxs_1.getCreationTx(id);
        const country = isoAlpha2ToAlpha3_1.default(providedCountry, items_1.countryItem.name); // May throw if country is not found
        const customerData = {
            firstName,
            lastName,
            dateOfBirth: generateDate(dateOfBirth),
            address: {
                street,
                town,
                postCode,
                country,
            },
            defaultCurrencyId: moonpayCountryData_1.fiatData[(yield creationTx).fiatCurrency].id,
        };
        if (country === "USA") {
            if (state === undefined ||
                typeof state !== "string" ||
                state.length === 0) {
                return {
                    type: "form",
                    url: `${constants_1.baseAPIUrl}/transaction/${constants_1.identifier}/identityState/${token_1.encodeToken([
                        id,
                        firstName,
                        lastName,
                        dateOfBirth.day,
                        dateOfBirth.month,
                        dateOfBirth.year,
                        street,
                        town,
                        postCode,
                        providedCountry,
                    ])}`,
                    data: [items_1.stateItem],
                };
            }
            const processedState = state.toUpperCase();
            if (!moonpayCountryData_1.USAStates.includes(processedState)) {
                throw new errors_1.StepError(`State provided is not a valid ISO 3166-1 alpha2 subdivision code for the US. Examples of valid codes are 'mt' for Montana and 'nv' for Nevada.`, items_1.stateItem.name);
            }
            if (moonpayCountryData_1.unsupportedUSAStates.includes(processedState)) {
                throw new errors_1.StepError("This state is not supported by Moonpay.", items_1.stateItem.name);
            }
            customerData.address.state = processedState;
            // Extra check on selected cryptocurrency (varies by country and it is possible to end up with an unaccepted currency if you are a USA resident with a different IP)
            const cryptoCurrency = (yield creationTx).cryptoCurrency;
            if (!moonpayCountryData_1.USsupportedCrypto.map((c) => c.code).includes(cryptoCurrency)) {
                throw new errors_1.StepError(`Cryptocurrency '${cryptoCurrency}' can't be sold to USA residents.`, null);
            }
        }
        else if (country === "CAN") {
            if (state === undefined ||
                typeof state !== "string" ||
                state.length === 0) {
                throw new errors_1.StepError("Please, fill a valid CAN state.", "state");
            }
            customerData.address.state = state.toUpperCase();
        }
        // Track customer actions
        dynamodb_1.default.put({
            PK: `tx#${id}`,
            SK: `registerIdentity`,
            Timestamp: Date.now(),
            alpha3Country: country,
            alpha2Country: providedCountry,
        });
        try {
            const updatedCustomerData = (yield fetch_1.default(`${constants_1.moonpayBaseAPI}/customers/me`, {
                method: "PATCH",
                headers: {
                    "Content-Type": "application/json",
                    "X-CSRF-TOKEN": (yield tokenTx).csrfToken,
                },
                credentials: "include",
                body: JSON.stringify(customerData),
            }).then((res) => res.json()));
            return getNextKYCStep_1.default(yield creationTx, (yield tokenTx).csrfToken, updatedCustomerData, onramperApiKey);
        }
        catch (e) {
            if (e instanceof errors_1.FetchError) {
                if (e.errorObject.type === "UnauthorizedError") {
                    throw new errors_1.StepError("This browser's cookie policy is not compatible with Moonpay, please use a different browser", null);
                }
                else if (e.errorObject.message ===
                    "Invalid body, check 'errors' property for more info.") {
                    let error = e.errorObject.errors[0];
                    if (error.constraints === undefined) {
                        error = error.children[0];
                    }
                    throw new errors_1.StepError(Object.values(error.constraints).join(", "), error.property);
                }
                else {
                    throw new errors_1.StepError(e.errorObject.message, null);
                }
            }
            else {
                throw e;
            }
        }
    });
}
exports.default = default_1;
