"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sentryHub = void 0;
const browser_1 = require("@sentry/browser");
const constants_1 = require("../constants");
const token_1 = require("../utils/token");
const errors_1 = require("../errors");
const moonpayCountryData_1 = require("../moonpayCountryData");
const fetch_1 = __importDefault(require("../utils/fetch"));
const getDocumentHumanName_1 = __importDefault(require("../documents/getDocumentHumanName"));
const items = __importStar(require("./items"));
const processDiligenceVerificationStep_1 = require("./processDiligenceVerificationStep");
const sentryClient = new browser_1.BrowserClient({
    dsn: "https://283a138678d94cc295852f634d4cdd1c@o506512.ingest.sentry.io/5638949",
    environment: process.env.STAGE,
});
exports.sentryHub = new browser_1.Hub(sentryClient);
function selectLimit(limits, txType) {
    return limits.limits.filter((l) => l.type === txType)[0];
}
function getAlpha3Country(alpha3Country) {
    if (alpha3Country === null) {
        throw new errors_1.InternalError("This point should never be reached, we are attempting to do document verification for a customer (passport...) but said customer hasn't registered it's identity yet (country is null).");
    }
    return alpha3Country;
}
function default_1(creationTx, token, customerData, onramperApiKey) {
    return __awaiter(this, void 0, void 0, function* () {
        exports.sentryHub.addBreadcrumb({ message: `creationtx`, data: creationTx });
        exports.sentryHub.addBreadcrumb({ message: `apikey`, data: { onramperApiKey } });
        exports.sentryHub.addBreadcrumb({ message: `customerData`, data: customerData });
        // TODO: This could be optimized by storing the result of limits between calls and predicting the changes to it based on our actions.
        // Essentially only the first call to the /limits endpoint is needed
        const limits = (yield fetch_1.default(`${constants_1.moonpayBaseAPI}/customers/me/limits`, {
            headers: {
                "X-CSRF-TOKEN": token,
            },
            credentials: "include",
        }).then((res) => res.json()));
        let txType;
        if (creationTx.paymentMethod === "creditCard") {
            txType = "buy_credit_debit_card";
        }
        else if (creationTx.paymentMethod === "sepaBankTransfer") {
            if (creationTx.fiatCurrency === "EUR") {
                txType = "buy_sepa_bank_transfer";
            }
            else if (creationTx.fiatCurrency === "GBP") {
                txType = "buy_gbp_bank_transfer";
            }
            else {
                throw new errors_1.InternalError("No currency other than EUR and GBP is allowed to make bank transfers.");
            }
        }
        else {
            throw new errors_1.InternalError("Payment method not accepted.");
        }
        const txId = creationTx.PK.split("#")[1];
        const currentLimit = Math.min(selectLimit(limits, txType).dailyLimitRemaining, selectLimit(limits, txType).monthlyLimitRemaining);
        if (creationTx.fiatAmount <= currentLimit) {
            if (creationTx.paymentMethod === "creditCard") {
                return {
                    type: "iframe",
                    fullscreen: false,
                    url: `${constants_1.baseCreditCardSandboxUrl}?customerId=${customerData.id}&customerAddress=${token_1.encodeJson(customerData.address)}&transactionId=${txId}&apiKey=${onramperApiKey}`,
                };
            }
            // Request bank data
            const fiatCurrency = creationTx.fiatCurrency;
            let requiredData;
            if (fiatCurrency === "EUR") {
                requiredData = [items.bankIbanItem];
            }
            else {
                requiredData = [items.bankSortCodeItem, items.bankAccountNumberItem];
            }
            return {
                type: "form",
                url: `${constants_1.baseAPIUrl}/transaction/${constants_1.identifier}/registerBank/${token_1.encodeToken([
                    txId,
                    token,
                    fiatCurrency,
                ])}`,
                data: requiredData,
            };
        }
        const missingKYC = limits.verificationLevels.filter((level) => level.completed === false);
        if (missingKYC.length === 0) {
            throw new errors_1.StepError("Transaction couldn't be completed because it exceeds all of Moonpay's limits (monthly or daily).", null);
        }
        else {
            const nextKYCLevel = missingKYC[0].requirements.filter((req) => req.completed === false)[0].identifier;
            if (nextKYCLevel === "phone_number_verification") {
                exports.sentryHub.addBreadcrumb({
                    message: `phone_number_verification`,
                    data: limits,
                });
                exports.sentryHub.addBreadcrumb({
                    message: `phone_number_verification`,
                    data: customerData,
                });
                // Get phone
                return {
                    type: "form",
                    url: `${constants_1.baseAPIUrl}/transaction/${constants_1.identifier}/registerPhone/${token_1.encodeToken([txId, token])}`,
                    data: [items.phoneCountryCodeItem, items.phoneNumberItem],
                };
            }
            if (nextKYCLevel === "document_verification") {
                const alpha3Country = getAlpha3Country(customerData.address.country);
                const possibleDocuments = moonpayCountryData_1.requiredDocumentsAlpha3[alpha3Country];
                exports.sentryHub.addBreadcrumb({
                    message: `document_verification`,
                    data: limits,
                });
                exports.sentryHub.addBreadcrumb({
                    message: `document_verification`,
                    data: customerData,
                });
                return {
                    type: "pickOne",
                    title: "Choose identity document",
                    options: possibleDocuments.map((docId) => {
                        let humanName;
                        try {
                            humanName = getDocumentHumanName_1.default(docId);
                        }
                        catch (e) {
                            throw new errors_1.InternalError(e);
                        }
                        return {
                            title: humanName || "",
                            icon: moonpayCountryData_1.documentTypeIcons[docId],
                            description: "Front",
                            nextStep: {
                                type: "file",
                                humanName,
                                url: `${constants_1.baseUploadsUrl}/${constants_1.identifier}/${docId}/${txId}/${alpha3Country}/${token}/front`,
                                acceptedContentTypes: constants_1.acceptedContentTypes,
                            },
                        };
                    }),
                };
            }
            if (nextKYCLevel === "face_match_verification") {
                exports.sentryHub.addBreadcrumb({
                    message: `face_match_verification`,
                    data: limits,
                });
                exports.sentryHub.addBreadcrumb({
                    message: `face_match_verification`,
                    data: customerData,
                });
                const alpha3Country = getAlpha3Country(customerData.address.country);
                return {
                    type: "file",
                    humanName: "Selfie",
                    url: `${constants_1.baseUploadsUrl}/${constants_1.identifier}/selfie/${txId}/${alpha3Country}/${token}/front`,
                    acceptedContentTypes: constants_1.acceptedContentTypes,
                };
            }
            if (nextKYCLevel === "address_verification") {
                exports.sentryHub.addBreadcrumb({
                    message: `address_verification`,
                    data: limits,
                });
                exports.sentryHub.addBreadcrumb({
                    message: `address_verification`,
                    data: customerData,
                });
                const alpha3Country = getAlpha3Country(customerData.address.country);
                return {
                    type: "file",
                    humanName: "Proof of Address",
                    hint: "Original, unedited photo or PDF of a bank statement, utility bill, tax return or council tax bill.",
                    url: `${constants_1.baseUploadsUrl}/${constants_1.identifier}/proof_of_address/${txId}/${alpha3Country}/${token}/front`,
                    acceptedContentTypes: constants_1.acceptedContentTypes,
                };
            }
            if (nextKYCLevel === "customer_due_diligence_verification") {
                return processDiligenceVerificationStep_1.generateDiligenceVerificationStep(txId, creationTx.fiatCurrency.toLowerCase(), token);
            }
            if (nextKYCLevel === "enhanced_due_diligence_verification") {
                const alpha3Country = getAlpha3Country(customerData.address.country);
                return processDiligenceVerificationStep_1.generateEnhancedDiligenceVerificationStep(txId, creationTx.fiatCurrency.toLowerCase(), alpha3Country, token);
            }
            if (nextKYCLevel === "identity_verification") {
                exports.sentryHub.addBreadcrumb({
                    message: `identity_verification`,
                    data: limits,
                });
                exports.sentryHub.addBreadcrumb({
                    message: `identity_verification`,
                    data: customerData,
                });
                throw new errors_1.InternalError("It is impossible to reach this point without finishing identity verification.");
            }
            else {
                exports.sentryHub.addBreadcrumb({
                    message: `Debug KYC level Moonpay ${JSON.stringify(limits)}`,
                    data: limits,
                });
                exports.sentryHub.captureException(new Error("Debug KYC level Moonpay!"));
                throw new errors_1.StepError(`Required KYC level is not supported by Onramper. Please, contact support@onramper.com providing the following information: Step: ${nextKYCLevel}. Tx id: ${txId}`, null);
            }
        }
    });
}
exports.default = default_1;
