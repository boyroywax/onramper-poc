"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const token_1 = require("./utils/token");
const errors_1 = require("./errors");
const KYC_1 = require("./KYC");
const items = __importStar(require("./KYC/items"));
const getNextKYCStepFromTxIdAndToken_1 = __importDefault(require("./KYC/getNextKYCStepFromTxIdAndToken"));
const registerBank_1 = __importDefault(require("./registerBank"));
const sendWaypoint_1 = __importDefault(require("./sendWaypoint"));
const index_1 = require("./index");
const processDiligenceVerificationStep_1 = __importStar(require("./KYC/processDiligenceVerificationStep"));
const hash_1 = __importDefault(require("./utils/hash"));
// Separated cause it's too bulky
function processIdentityState(tokenValues, body, onramperApiKey) {
    if (!token_1.checkTokenTypes(tokenValues, ["", "", "", 0, 0, 0, "", "", "", ""])) {
        throw new errors_1.StepError("URL is incorrect.", null);
    }
    const [id, firstName, lastName, day, month, year, street, town, postCode, providedCountry,] = tokenValues;
    token_1.checkBodyParams(body, [items.stateItem]);
    const state = body[items.stateItem.name];
    if (state === "") {
        throw new errors_1.StepError(`Parameter ${items.stateItem.name} must not be empty.`, items.stateItem.name);
    }
    return KYC_1.registerIdentity(id, onramperApiKey, firstName, lastName, { day, month, year }, street, town, postCode, body[items.stateItem.name], providedCountry);
}
function default_1(step, token, body, onramperApiKey, country) {
    return __awaiter(this, void 0, void 0, function* () {
        let tokenValues;
        try {
            tokenValues = token_1.decodeToken(token);
        }
        catch (e) {
            throw new errors_1.StepError("URL is incorrect.", null);
        }
        let nextStepPromise;
        if (step === "email") {
            index_1.setPartnerContext(body.partnerContext);
            if (!token_1.checkTokenTypes(tokenValues, [
                "",
                0,
                "",
                "",
                "",
            ])) {
                throw new errors_1.StepError("URL is incorrect.", null);
            }
            const [id, amount, fiatCurrency, cryptoCurrency, paymentMethod,] = tokenValues;
            token_1.checkBodyParams(body, [
                items.emailItem,
                items.cryptocurrencyAddress,
                items.cryptocurrencyAddressTag,
            ]);
            nextStepPromise = KYC_1.registerEmail(id, amount, fiatCurrency, cryptoCurrency, paymentMethod, onramperApiKey, body[items.emailItem.name], body[items.cryptocurrencyAddress.name], body[items.cryptocurrencyAddressTag.name], country);
            /* eslint-disable no-param-reassign */
            body[items.emailItem.name] = yield hash_1.default(body[items.emailItem.name]);
        }
        else if (step === "verifyEmail") {
            if (!token_1.checkTokenTypes(tokenValues, ["", ""])) {
                throw new errors_1.StepError("URL is incorrect.", null);
            }
            const [id, email] = tokenValues;
            token_1.checkBodyParams(body, [items.verifyEmailCodeItem]);
            nextStepPromise = KYC_1.verifyEmail(id, email, body[items.verifyEmailCodeItem.name], onramperApiKey, country);
        }
        else if (step === "identity") {
            if (!token_1.checkTokenTypes(tokenValues, [""])) {
                throw new errors_1.StepError("URL is incorrect.", null);
            }
            const [id] = tokenValues;
            token_1.checkBodyParams(body, [
                items.firstNameItem,
                items.lastNameItem,
                items.dateOfBirthItem,
                items.streetItem,
                items.townItem,
                items.postCodeItem,
                items.countryItem,
            ]); // Doesn't include 'state', it's optional
            nextStepPromise = KYC_1.registerIdentity(id, onramperApiKey, body[items.firstNameItem.name], body[items.lastNameItem.name], body[items.dateOfBirthItem.name], body[items.streetItem.name], body[items.townItem.name], body[items.postCodeItem.name], body[items.stateItem.name], body[items.countryItem.name]);
        }
        else if (step === "identityState") {
            nextStepPromise = processIdentityState(tokenValues, body, onramperApiKey);
        }
        else if (step === "diligenceVerification") {
            nextStepPromise = processDiligenceVerificationStep_1.default(tokenValues, body, onramperApiKey);
        }
        else if (step === "proofOfIncome") {
            nextStepPromise = processDiligenceVerificationStep_1.processsEnhancedDiligenceVerificationProofOfIncomeStep(tokenValues, body, onramperApiKey);
        }
        else if (step === "getNextKYCStep") {
            if (!token_1.checkTokenTypes(tokenValues, ["", ""])) {
                throw new errors_1.StepError("URL is incorrect.", null);
            }
            const [id, csrfToken] = tokenValues;
            nextStepPromise = getNextKYCStepFromTxIdAndToken_1.default(id, csrfToken, onramperApiKey);
        }
        else if (step === "registerPhone") {
            if (!token_1.checkTokenTypes(tokenValues, ["", ""])) {
                throw new errors_1.StepError("URL is incorrect.", null);
            }
            const [id, csrfToken] = tokenValues;
            token_1.checkBodyParams(body, [items.phoneCountryCodeItem, items.phoneNumberItem]);
            nextStepPromise = KYC_1.registerPhone(id, csrfToken, body[items.phoneCountryCodeItem.name], body[items.phoneNumberItem.name]);
        }
        else if (step === "verifyPhone") {
            if (!token_1.checkTokenTypes(tokenValues, ["", ""])) {
                throw new errors_1.StepError("URL is incorrect.", null);
            }
            const [id, csrfToken] = tokenValues;
            token_1.checkBodyParams(body, [items.verifyPhoneCodeItem]);
            nextStepPromise = KYC_1.verifyPhone(id, csrfToken, body[items.verifyPhoneCodeItem.name], onramperApiKey);
        }
        else if (step === "registerBank") {
            if (!token_1.checkTokenTypes(tokenValues, ["", "", ""])) {
                throw new errors_1.StepError("URL is incorrect.", null);
            }
            const [id, csrfToken, fiatCurrency] = tokenValues;
            if (fiatCurrency === "EUR") {
                token_1.checkBodyParams(body, [items.bankIbanItem]);
                nextStepPromise = registerBank_1.default(id, csrfToken, {
                    currencyCode: "eur",
                    iban: body[items.bankIbanItem.name],
                });
            }
            else if (fiatCurrency === "GBP") {
                token_1.checkBodyParams(body, [
                    items.bankSortCodeItem,
                    items.bankAccountNumberItem,
                ]);
                nextStepPromise = registerBank_1.default(id, csrfToken, {
                    currencyCode: "gbp",
                    accountNumber: body[items.bankAccountNumberItem.name],
                    sortCode: body[items.bankSortCodeItem.name],
                });
            }
            throw new errors_1.StepError("URL is incorrect, unaccepted fiat currency.", null);
        }
        else if (step === "registerCreditCardToken") {
            throw new errors_1.StepError(`The last step of the credit card flow, 'registerCreditCardToken', should not be called through the default method, instead it should be called with the function 'finishCCTransaction' that is directly exported from the package. Check the package's readme for more details.`, null);
        }
        else {
            throw new errors_1.StepError(`Step '${step}' is not defined for Moonpay.`, null);
        }
        if (step !== "getNextKYCStep") {
            // ignore this step as nothing new is stored.
            sendWaypoint_1.default(token, onramperApiKey, step, body);
        }
        return nextStepPromise;
    });
}
exports.default = default_1;
